module Transformations.Parsers.XML.XmlConfigurationKnowledge
where

import BasicTypes

import ConfigurationKnowledge.Types

import Transformations.ComponentModel
import Transformations.UseCaseModel

import UseCaseModel.Types

import FeatureModel.Parsers.Expression
import FeatureModel.Types hiding (Success,Fail)

import Text.XML.HXT.Arrow

import Text.ParserCombinators.Parsec
import qualified Text.ParserCombinators.Parsec.Token as P
import Text.ParserCombinators.Parsec.Language( haskellStyle )

import List
         
data XmlConfigurationKnowledge = XmlConfigurationKnowledge {
      xmlConfigurations :: [XmlConfiguration]
} deriving(Show)  
	
data XmlConfiguration = XmlConfiguration {
      xmlExpression:: String,
      xmlTransformations :: [XmlTransformation],
      xmlRequired :: Maybe String, 
      xmlProvided :: Maybe String
} deriving(Show)  	
	
data XmlTransformation = XmlTransformation {
      tName :: String,
      tArgs :: String
} deriving(Show)

xml2ConfigurationKnowledge :: XmlConfigurationKnowledge -> ParserResult ConfigurationKnowledge
xml2ConfigurationKnowledge ck = 
 let 
   cs  = xmlConfigurations ck
   mcs = map xml2Configuration cs
 in 
  if and [isSuccess c | c <- mcs]
   then Success [ci | (Success ci) <- mcs]
   else Fail (unwords [showError e | e <- mcs, isSuccess e == False])

xml2Configuration :: XmlConfiguration -> ParserResult Configuration 
xml2Configuration c =
 let 
  e  = parse parseExpression "" (xmlExpression c)
  ts = map xml2Transformation (xmlTransformations c)
  r  = parseConstraint (xmlRequired c)
  p  = parseConstraint (xmlProvided c)  
 in 
  case e of
   Left err -> Fail ("Error parsing expression " ++ (xmlExpression c))
   Right exp -> 
    if and [isSuccess t | t <- ts] 
       then Success (ConstrainedConfiguration { expression = exp
 					      , transformations = [a | (Success a) <- ts] 
					      , required = r 
					      , provided = p })

       else Fail (unwords [showError e | e <- ts, isSuccess e == False])

xml2Transformation :: XmlTransformation -> ParserResult GenT
xml2Transformation t = 
 let as = splitAndTrim ',' (tArgs t)
 in 
  case tName t of 
   "selectScenarios" -> Success (GenT (SelectScenarios as))

   "selectUseCases" -> Success (GenT (SelectUseCases as))
   
   "bindParameter" -> case as of
                       [x,y] -> Success (GenT (BindParameter x y))
                       otherwise -> Fail "Invalid number of arguments to the bind parameter transformation"
   
   "evaluateAspects" -> Success (GenT (EvaluateAspects as))
   
   "selectComponents" -> Success (GenT (SelectComponents as))

   "selectAndMoveComponent" -> case as of
                                [x,y] -> Success (GenT (SelectAndMoveComponent x y))
                                otherwise -> Fail "Invalid number of arguments to the select and move transformation"

   "createBuildEntries" -> Success (GenT (CreateBuildEntries as))
   
   "preprocessFiles" -> Success (GenT (PreProcessor as))

   otherwise -> Fail ("Invalid transformation: " ++ tName t)

parseConstraint :: Maybe String -> FeatureExpression
parseConstraint Nothing = expTrue
parseConstraint (Just s)  = 
 let p = parse parseExpression "" s
 in case p of
     (Left _) -> expFalse
     (Right e) -> e 	
