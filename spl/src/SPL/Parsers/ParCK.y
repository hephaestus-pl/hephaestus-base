-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ConfigurationKnowledge.Parsers.ParCK where
import ConfigurationKnowledge.Parsers.AbsCK
import ConfigurationKnowledge.Parsers.LexCK
import ConfigurationKnowledge.Parsers.ErrM
}

%name pConfigurationKnowledge ConfigurationKnowledge
%name pConfigurationItem ConfigurationItem
%name pTransformation Transformation
%name pScenarioId ScenarioId
%name pAdviceId AdviceId
%name pFeatureExp FeatureExp
%name pListConfigurationItem ListConfigurationItem
%name pListTransformation ListTransformation
%name pListScenarioId ListScenarioId
%name pListAdviceId ListAdviceId

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 'configuration knowledge' { PT _ (TS "configuration knowledge") }
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 '=>' { PT _ (TS "=>") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 ',' { PT _ (TS ",") }
 ';' { PT _ (TS ";") }
 'And' { PT _ (TS "And") }
 'Not' { PT _ (TS "Not") }
 'Or' { PT _ (TS "Or") }
 'bindParameter' { PT _ (TS "bindParameter") }
 'evaluateAdvice' { PT _ (TS "evaluateAdvice") }
 'selectScenario' { PT _ (TS "selectScenario") }

L_ident  { PT _ (TV $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }

ConfigurationKnowledge :: { ConfigurationKnowledge }
ConfigurationKnowledge : 'configuration knowledge' '{' ListConfigurationItem '}' { TConfigurationKnowledge $3 } 


ConfigurationItem :: { ConfigurationItem }
ConfigurationItem : FeatureExp '=>' ListTransformation { TConfigurationItem $1 $3 } 


Transformation :: { Transformation }
Transformation : 'selectScenario' '(' ListScenarioId ')' { TSelectScenario $3 } 
  | 'evaluateAdvice' '(' ListAdviceId ')' { TEvaluateAdvice $3 }
  | 'bindParameter' '(' Ident ',' Ident ')' { TBindParameter $3 $5 }


ScenarioId :: { ScenarioId }
ScenarioId : Ident { TScenarioId $1 } 


AdviceId :: { AdviceId }
AdviceId : Ident { TAdviceId $1 } 


FeatureExp :: { FeatureExp }
FeatureExp : Ident { TBasicExp $1 } 
  | 'And' '(' FeatureExp ',' FeatureExp ')' { TAndExp $3 $5 }
  | 'Or' '(' FeatureExp ',' FeatureExp ')' { TOrExp $3 $5 }
  | 'Not' '(' FeatureExp ')' { TNotExp $3 }


ListConfigurationItem :: { [ConfigurationItem] }
ListConfigurationItem : {- empty -} { [] } 
  | ConfigurationItem { (:[]) $1 }
  | ConfigurationItem ';' ListConfigurationItem { (:) $1 $3 }


ListTransformation :: { [Transformation] }
ListTransformation : {- empty -} { [] } 
  | Transformation { (:[]) $1 }
  | Transformation ',' ListTransformation { (:) $1 $3 }


ListScenarioId :: { [ScenarioId] }
ListScenarioId : {- empty -} { [] } 
  | ScenarioId { (:[]) $1 }
  | ScenarioId ',' ListScenarioId { (:) $1 $3 }


ListAdviceId :: { [AdviceId] }
ListAdviceId : {- empty -} { [] } 
  | AdviceId { (:[]) $1 }
  | AdviceId ',' ListAdviceId { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map prToken (take 4 ts))

myLexer = tokens
}

