-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module SPL.Parsers.ParCK where
import SPL.Parsers.AbsCK
import SPL.Parsers.LexCK
import SPL.Parsers.ErrM

}

%name pConfigurationKnowledge ConfigurationKnowledge
%name pConfigurationItem ConfigurationItem
%name pTransformation Transformation
%name pId Id
%name pFeatureExp FeatureExp
%name pListConfigurationItem ListConfigurationItem
%name pListTransformation ListTransformation
%name pListId ListId

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '(' { PT _ (TS _ 1) }
 ')' { PT _ (TS _ 2) }
 ',' { PT _ (TS _ 3) }
 ';' { PT _ (TS _ 4) }
 'And' { PT _ (TS _ 5) }
 'Not' { PT _ (TS _ 6) }
 'Or' { PT _ (TS _ 7) }
 'bindParameter' { PT _ (TS _ 8) }
 'configuration knowledge' { PT _ (TS _ 9) }
 'evaluateAdvice' { PT _ (TS _ 10) }
 'selectAndMoveComponent' { PT _ (TS _ 11) }
 'selectBuildEntries' { PT _ (TS _ 12) }
 'selectComponents' { PT _ (TS _ 13) }
 'selectScenario' { PT _ (TS _ 14) }
 '{' { PT _ (TS _ 15) }
 '}' { PT _ (TS _ 16) }

L_ident  { PT _ (TV $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }

ConfigurationKnowledge :: { ConfigurationKnowledge }
ConfigurationKnowledge : 'configuration knowledge' '{' ListConfigurationItem '}' { TConfigurationKnowledge $3 } 


ConfigurationItem :: { ConfigurationItem }
ConfigurationItem : '(' FeatureExp ',' ListTransformation ')' { TBasicConfigurationItem $2 $4 } 
  | '(' FeatureExp ',' ListTransformation ',' FeatureExp ',' FeatureExp ')' { TConstrainedConfigurationItem $2 $4 $6 $8 }


Transformation :: { Transformation }
Transformation : 'selectScenario' '(' ListId ')' { TSelectScenario $3 } 
  | 'evaluateAdvice' '(' ListId ')' { TEvaluateAdvice $3 }
  | 'bindParameter' '(' Ident ',' Ident ')' { TBindParameter $3 $5 }
  | 'selectComponents' '(' ListId ')' { TSelectComponents $3 }
  | 'selectAndMoveComponent' '(' Id ',' Id ')' { TSelectAndMoveComponent $3 $5 }
  | 'selectBuildEntries' '(' ListId ')' { TSelectBuildEntries $3 }


Id :: { Id }
Id : Ident { TId $1 } 


FeatureExp :: { FeatureExp }
FeatureExp : Ident { TBasicExp $1 } 
  | 'And' '(' FeatureExp ',' FeatureExp ')' { TAndExp $3 $5 }
  | 'Or' '(' FeatureExp ',' FeatureExp ')' { TOrExp $3 $5 }
  | 'Not' '(' FeatureExp ')' { TNotExp $3 }


ListConfigurationItem :: { [ConfigurationItem] }
ListConfigurationItem : {- empty -} { [] } 
  | ConfigurationItem { (:[]) $1 }
  | ConfigurationItem ';' ListConfigurationItem { (:) $1 $3 }


ListTransformation :: { [Transformation] }
ListTransformation : {- empty -} { [] } 
  | Transformation { (:[]) $1 }
  | Transformation ',' ListTransformation { (:) $1 $3 }


ListId :: { [Id] }
ListId : {- empty -} { [] } 
  | Id { (:[]) $1 }
  | Id ',' ListId { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

